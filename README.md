
-----------------------------------------------------------------------
# Серия задач на структуры данных
Здесь будут решения с разъяснениями

-----------------------------------------------------------------------
# A. ArrayList (Динамический массив)
1. Разворот списка на месте (reverse)
2. Удаление дубликатов из отсортированного списка (in-place). 
3. Слияние двух отсортированных списков в один. 
4. Поиск пересечения двух списков (с повторениями или без). 
5. Циклический сдвиг на k позиций.

-----------------------------------------------------------------------
# B. LinkedList (Связный список)
1. Разворот односвязного списка (итеративно и рекурсивно). 
2. Определение, есть ли в списке цикл (задача "Черепаха и заяц"). 
3. Удаление N-го узла с конца списка. 
4. Объединение двух отсортированных связных списков. 
5. Палиндромность списка (проверка без дополнительной памяти).

-----------------------------------------------------------------------
# C. HashMap / HashSet
1. Поиск двух чисел в массиве, дающих в сумме target (Two Sum). 
2. Проверка, является ли строка анаграммой другой. 
3. Поиск первого неповторяющегося символа в строке. 
4. Группировка слов по анаграммам (например, ["eat", "tea", "ate"] → ["eat", "tea", "ate"]). 
5. Подсчёт количества подмассивов с заданной суммой.

-----------------------------------------------------------------------
# D. Стек (Stack)
1. Проверка корректности скобочной последовательности.  
2. Обратная польская запись (вычисление выражений типа "3 4 + 5 *"). 
3. Минимальный стек (поддержка getMin() за O(1)). 
4. Удаление дубликатов из строки с сохранением порядка (например, "abbaca" → "ca"). 
5. Обход графа в глубину (DFS) с использованием стека.

-----------------------------------------------------------------------
# E. Очередь (Queue) / Дек (Deque)
1. Реализация очереди с использованием двух стеков. 
2. Циклический буфер (Ring Buffer). 
3. Нахождение скользящего максимума в массиве (Sliding Window Maximum). 
4. Обход графа в ширину (BFS) с использованием очереди. 
5. Проверка, можно ли построить очередь из двух стеков с O(1) на операцию.

-----------------------------------------------------------------------
# F. Деревья (Binary Tree, BST)
1. Обход дерева (in-order, pre-order, post-order, level-order). 
2. Проверка, является ли дерево сбалансированным. 
3. Поиск наименьшего общего предка (LCA) для двух узлов. 
4. Проверка, является ли дерево бинарным деревом поиска (BST). 
5. Построение дерева из inorder и preorder/postorder обходов.

-----------------------------------------------------------------------
# G. Графы (Graphs)
1. Поиск в глубину (DFS) и в ширину (BFS). 
2. Проверка, есть ли цикл в ориентированном/неориентированном графе. 
3. Топологическая сортировка (для DAG). 
4. Алгоритм Дейкстры (кратчайший путь в графе без отрицательных весов). 
5. Поиск количества связных компонент (Union-Find).

-----------------------------------------------------------------------
# H. Куча (Heap / PriorityQueue)
1. Поиск K-го наибольшего/наименьшего элемента в массиве. 
2. Слияние K отсортированных списков. 
3. Поиск медианы в потоке данных. 
4. Реализация планировщика задач с приоритетами. 
5. Максимум в скользящем окне (альтернатива через кучу).

-----------------------------------------------------------------------
# I. Строки (String)
1. Поиск K-го наибольшего/наименьшего элемента в массиве.
2. Слияние K отсортированных списков.
3. Поиск медианы в потоке данных.
4. Реализация планировщика задач с приоритетами.
5. Максимум в скользящем окне (альтернатива через кучу).



